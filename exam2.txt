Кэширование:

Ядро грузит компонент в таком порядке:
При формировании каталога ищет .description.php, разбирает метаданные, выводит каталоге компонентов
При подключении компонента/открытии меню настроек компонента ищет .parameters.php, отрабатывает
После $arCurrentValues передается в component.php как $arParams
Отрабатывает component.php до секции кэша
Если есть кэш - он выводится, из него десериализуется $arResult, и управление передается в конец component.php, после секции кэша
Если кэша нет - штатно отрабатывает секция кэша
В секции кэша ядро включает html-кэш, весь вывод (echo например) падает в буфер
Отрабатывает наш код компонента, запрашивающий данные из БД
На основе этих данных кодом формируем $arResult удобной нам структуры
Далее помечаем часть корневых веток $arResult: $this->setResultCacheKeys(['IBLOCK_ID','CNT'])
Далее в конце секции подключаем шаблон $this->includeComponentTemplate()
При подключении шаблона происходит много интересного:
-отрабатывает result_modifier.php, если есть, дополнительно преобразующий $arResult 
-отрабатывает шаблон, найденный в $arParams, при этом ему доступен полный массив $arResult
-вывод шаблона, html со вшитыми значениями из $arResult, падает в буфер
-если мы ничего не передали в setResultCacheKeys, ядро сериализует весь $arResult в буфер
-если мы передали в setResultCacheKeys пустой массив, ядро не сериализует $arResult
-если мы передали в setResultCacheKeys массив с ключами, ядро сериализует в буфер только переданные ветки $arResult
-кеширование завершается, буфер сбрасывается на диск
-отрабатывает component_epilog.php, если есть
Далее управление переходит в конец component.php, после секции кэша


Рассмотрим внимательнее включение кэша
$this->startResultCache($cacheTime,$id,$path)

Если $cacheTime === false
$cacheTime = intval($this->arParams["CACHE_TIME"]);
т.е. можно не задавать, берется из arParams

Как генерируется дефолтный cacheID:
$cacheID='SITE_ID|LANGUAGE_ID|SITE_TEMPLATE_NAME|#component_namespace#:#component_name#|#component_template_name#|';
Пример: s1|ru|furniture_pale-blue|custom:list.vacancy|.default|
Далее добавляется каждый корневой элемент $arParams, начинающийся не на ~
Пример: s1|ru|furniture_pale-blue|custom:list.vacancy|.default|,CACHE_TIME=s:8:"36000000";,CACHE_TYPE=s:1:"A";,IBLOCK_ID=i:4;,IBLOCK_TYPE=s:9:"vacancies";
Далее добавляется смещение временной зоны, если оно не нулевое
Далее добавляется переданный нами $id, если он не нулевой
т.е. если нет зависимости по данным, можно не передавать ничего
А если передать - оно просто добавляется к $cacheID
Так что достаточно передать только наши зависимости по данным

$path по умолчанию
$path = "/".SITE_ID.$relativePath."/".substr(md5($scriptName), 0, 3);
где $scriptName - путь к текущей страничке от корня сайта, например '/test.php'
пример: /s1/custom/list.vacancy/bf6

Таким образом кэш зависит от:
-SITE_ID
-LANGUAGE_ID
-SITE_TEMPLATE_NAME
-#component_namespace#
-#component_name#
-#component_template_name#|
-параметров компонента
-переданных нами зависимостей
-адреса странички от корня сайта

При любом изменении любого из этих элементов генерируется новый файл кэша.
Таким образом для каждого набора этих элементов генерируется свой файл кэша.
Если он уже был сгенерирован ранее - он просто подгружается с диска.
Это обеспечивает высокую вариабельность кеша - для каждого уникального набора элементов создается свой файл кэша одного и того же компонента
Но если какой-то из этих элементов меняется произвольно - кэш забивается ненужными, холодными данными. И если такие изменения идут часто - это ведет к быстрому исчерпанию места на диске, и отказу сервера.
Так что за передаваемыми зависимостями нужно следить. Если они меняются произвольно, т.е. значений элемента много, и вероятность выпадения каждого низка, для таких данных кэш не нужен, он не будет работать, эти зависимости следует убрать из $cacheID, и реализовать их вывод иначе, поверх кеша

Тонкости кэширования:
-кэширование работает только для компонентов, конечная страничка сшивается из кешей компонентов на каждом хите
-полностраничного кэша нет
-кэш не может быть вложенным, но можно кешировать части компонента последовательно, и выводить одну в другой через ShowViewContent

**********************************************************************************************

Структура компонента:
В каждом php в начале проверяем пролог:
<? if (!defined('B_PROLOG_INCLUDED') || B_PROLOG_INCLUDED !== true)
	die();


.parameters.php:
на входе ничего
внутри $arCurrentValues - результат ввода пользователя
на выходе $arComponentParameters

//проверяем существование модулей
if (!CModule::IncludeModule('iblock'))
	return;

//формируем списки элементов из БД
$arIblockTypes = CIBlockParameters::GetIBlockTypes();
$arIblockIds = [];
if (isset($arCurrentValues['IBLOCK_TYPE']))
{
	$DbRes = CIBlock::GetList('', ["TYPE" => $arCurrentValues['IBLOCK_TYPE'], 'ACTIVE' => 'Y']);
	while ($iblock = $DbRes->Fetch())
	{
		$arIblockIds[$iblock['ID']] = '[' . $iblock['ID'] . '] ' . $iblock['NAME'];
	}
}

$arComponentParameters = ['GROUPS'     => ["BASE" => ["NAME" => GetMessage('BASE'),
                                                      "SORT" => "10",]],
                          'PARAMETERS' => ["IBLOCK_TYPE" => ["PARENT"  => "BASE",
                                                             "NAME"    => GetMessage('IBLOCK_TYPE'),
                                                             "TYPE"    => "LIST",
                                                             "REFRESH" => "Y",
                                                             "VALUES"  => $arIblockTypes,],
                                           "IBLOCK_ID"   => ["PARENT" => "BASE",
                                                             "NAME"   => GetMessage('IBLOCK_ID'),
                                                             "TYPE"   => "LIST",
                                                             "VALUES" => $arIblockIds,],
                                           "CACHE_TIME"  => ["DEFAULT" => 36000000]]

];
?>

на входе $arParams
~проверка существования ключевых параметров
~установка дефолтных значений для пустых параметров
~проверка формата параметров: trim, int_val, etc

if ($this->startResultCache())
{
	//проверка существования модулей, выдача ошибок
		if (!CModule::IncludeModule("iblock"))
	{
		$this->abortResultCache();
		ShowError('Модуль инфоблоков не найден');
		return;
	}

	if (!$arParams["IBLOCK_ID"])
	{
		//если параметр не задан - выводим пустую страницу
		$this->abortResultCache();
		return;
	}

	~запросы к БД
	~формирование $arResult
	
	//ограничение кэша
	$this->setResultCacheKeys(array("LAST_ITEM_IBLOCK_ID",));
	
	//подключение шаблона
	$this->includeComponentTemplate();
}

**********************************************************************************************

отладчик для экзамена:

init.php:
function mydebug(&$string, $die = false, $fname = '')
{
	file_put_contents($_SERVER['DOCUMENT_ROOT'] . '/debug_' . $fname . '.txt',
	                  date('H:i:s') . PHP_EOL . mydump($string));
	if ($die)
		die();
}
Для дампа массивов, когда их нельзя вывести на экран, например в обработчиках событий
**********************************************************************************************
//в шаблоне компонента параметры отображены в массив
.parameters.php
$arTemplateParameters == $arComponentParameters['PARAMETERS']
**********************************************************************************************
CDBResult::SelectedRowsCount() - количество элементов в выборке
**********************************************************************************************
//отмена кэширования при ошибках
if (!CModule::IncludeModule("iblock"))
	{
		$this->abortResultCache();
		ShowError(GetMessage('MODULE_NOT_FOUND'));
		return;
	}
**********************************************************************************************
Логика в фильтре:
['LOGIC'=>'AND',
 ['PROPERTY_1' => $other_id],
 ['!PROPERTY_1' => $my_id]
]
**********************************************************************************************
//пункт в меню компонента
if ($APPLICATION->GetShowIncludeAreas())
	$this->AddIncludeAreaIcons([
	["TITLE"          => GetMessage("IB_MENU"),
	 "URL"            => '/bitrix/admin/iblock_element_admin.php?IBLOCK_ID='.$arParams['NEWS_IBLOCK_ID'].'&type='.$arResult['IBLOCK_TYPE'],
	 "IN_PARAMS_MENU" => true, //флажки задают размещение
	 "IN_MENU"        => false]
	                            ]);

if ($APPLICATION->GetShowIncludeAreas())
	$this->AddIncludeAreaIcons([["TITLE"          => GetMessage("NEWS_LIST"),
	                             "URL"            => '/bitrix/admin/'
	                                                 . CIBlock::GetAdminElementListLink($arParams['NEWS_IBLOCK_ID']),
	                             "IN_PARAMS_MENU" => true //показать в контекстном меню
	                             "IN_MENU"        => false, //показать в подменю компонента
	                            ]]);
**********************************************************************************************
//mysql help
mysql -uroot -ppass
show databases;
use db_name;
show tables from exam2tier1_demoAll;
show columns from b_iblock_element;
select id,show_counter from b_iblock_element where iblock_id=2 and id=34;
update b_iblock_element set show_counter=100 where iblock_id=2 and id=34;
**********************************************************************************************
//exeption
$GLOBALS['APPLICATION']->ThrowException('text');
**********************************************************************************************
//журнал событий
CEventLog::Log('INFO', 'событие', 'main', 'обьект', 'описание');
**********************************************************************************************
//путь
$_SERVER['REQUEST_URI']
/products/2/20/
**********************************************************************************************
//отладка запросов к бд
//while ($tmp[]=$Res->Fetch());mydebug($tmp,1);
**********************************************************************************************
//автозамена шаблона url
$Res=IBlockElement::GetList(*******); //get result
$Res->SetUrlTemplates($arParams['URL_TEMPLATE']); //set template
while($Res->GetNext()) //edit url

//ручная замена (в случае если нет доступа к телу компонента, нельзя вставить код между запросом к бд и выборкой)
$url = '/aam/new/?PARAM1=#PARAM1#&PARAM2=#PARAM2#';
$arRepl=['#PARAM1#'=>123,
         '#PARAM2#'=>456];
$url=str_replace(array_keys($arRepl),$arRepl,$url);
**********************************************************************************************
//уникальный идентификатор, чтобы эрмитаж корректно обрабатывал дубли новостей
$id=$news_id+$count++;
$this->AddEditAction($id, $arResult[$news_id]['EDIT_LINK'],
                                         CIBlock::GetArrayByID($arResult[$news_id]["IBLOCK_ID"], "ELEMENT_EDIT"));
$this->AddDeleteAction($id, $arResult[$news_id]['DELETE_LINK'],
                                           CIBlock::GetArrayByID($arResult[$news_id]["IBLOCK_ID"], "ELEMENT_DELETE"),
                                           array("CONFIRM" => GetMessage('CT_BNL_ELEMENT_DELETE_CONFIRM')));
***
<li id="<?=$this->GetEditAreaId($id);?>">
**********************************************************************************************
//ссылка на список элементов в админке
'/bitrix/admin/'.CIBlock::GetAdminElementListLink('iblock_id')

**********************************************************************************************
//пагинация

.parameters.php
//задаем размер страницы
$arComponentParameters = array(
	"PARAMETERS" => array(
		"PAGE_SIZE" => array(
			'PARENT' => 'BASE',
			"NAME" => GetMessage("PAGE_SIZE"),
			"TYPE" => "STRING",
			'DEFAULT' => '1',
		),
	),
);

component.php
if ($arParams['PAGE_SIZE'] > 0) //если пагинация нужна
{
	//выключаем запоминание последней страницы в сессии
	CPageOption::SetOptionString("main", "nav_page_in_session", "N");
	//указываем размер страницы
	$arNavParams = array("nPageSize"          => $arParams["PAGE_SIZE"],
	                     "bDescPageNumbering" => false,
	                     "bShowAll"           => false);
	//получаем номер текущей страницы
	$arNavigation = CDBResult::GetNavParams($arNavParams);
	//формируем айди кэша
	$cacheID = array_merge($arNavigation, $arNavParams);
}
else //иначе формируем пустые переменные
{
	$arNavParams = false;
	$arNavigation = '';
	$cacheID = '';
}

if ($this->startResultCache(false, $cacheID))
{
	//запрашиваем ограниченный список
	$Res = CIBlockElement::GetList(false,$filter,false,$arNavParams,$select);

	if ($arParams['PAGE_SIZE'] > 0)
	{
		//ограничиваем выдачу
		$Res->NavStart($arParams['PAGE_SIZE']);
		//сохраняем пагинатор
		$arResult["NAV_STRING"] = $Res->GetPageNavStringEx($navComponentObject, 'Страницы');
	}

	$this->includeComponentTemplate();
}

template.php
//выводим пагинатор
<br /><?=$arResult["NAV_STRING"]?>

основные моменты:
1 - формат вызова кэша $this->startResultCache(false, $cacheID), легко перепутать, много проблем

**********************************************************************************************
//сброс кэша при изменении инфоблока

Добавить
$GLOBALS['CACHE_MANAGER']->RegisterTag("iblock_id_" . "id инфоблока");
в тело кешируемой части компонента, у которого нужно сбросить кэш
При изменении инфоблока автоматически будет сбрасываться кэш

управляемый кеш инфоблоков очищается только при вызове Update. При изменении, например, свойств с помощью SetPropertyValueCode очистки не произойдет. Делаем вручную после изменения

ручной сброс
$CACHE_MANAGER->ClearByTag("iblock_id_7");
или
CIBlock::clearIblockTagCache( 7 );

отключить привязку
CIBlock::DisableTagCache($iblock_id)

*******************************************************************************************
//комплексный компонент, маршрутизация
1 - добавить алиасы для нечпу, и шаблон пути для чпу
"PARAMETERS" => array(
		"VARIABLE_ALIASES" => Array(
			"SECTION_ID" => Array("NAME" => GetMessage("SECTION_ID_DESC")),
			"ELEMENT_ID" => Array("NAME" => GetMessage("ELEMENT_ID_DESC")),
			//Добавили переменные
			"PARAM1" => Array("NAME" => GetMessage("PARAM1")),
			"PARAM2" => Array("NAME" => GetMessage("PARAM2")),
),
		"SEF_MODE" => Array(
			"sections_top" => array(
				"NAME" => GetMessage("SECTIONS_TOP_PAGE"),
				"DEFAULT" => "",
				"VARIABLES" => array(),
			),
			"section" => array(
				"NAME" => GetMessage("SECTION_PAGE"),
				"DEFAULT" => "#SECTION_ID#/",
				"VARIABLES" => array("SECTION_ID"),
			),
			"detail" => array(
				"NAME" => GetMessage("DETAIL_PAGE"),
				"DEFAULT" => "#SECTION_ID#/#ELEMENT_ID#/",
				"VARIABLES" => array("ELEMENT_ID", "SECTION_ID"),
			),
				
			//добавили новую страницу
			"exampage" => array(
					"NAME" => GetMessage("EXAM_PAGE"),
					'DEFAULT' => 'exam/new/#PARAM1#/?PARAM2=#PARAM2#',
					'VARIABLES' => 'PARAM1, PARAM2',
			),

2 - чпу разберется сам, а для нечпу добавим условия выбора страницы
	elseif(isset($arVariables["PARAM1"]) && strlen($arVariables["PARAM1"]) > 0)
		$componentPage = "exampage";
И сам шаблон пути в нечпу режиме
	$arResult = array(
		"URL_TEMPLATES" => Array(
			"section" => htmlspecialcharsbx($APPLICATION->GetCurPage())."?".$arVariableAliases["SECTION_ID"]."=#SECTION_ID#",
			"detail" => htmlspecialcharsbx($APPLICATION->GetCurPage())."?".$arVariableAliases["SECTION_ID"]."=#SECTION_ID#"."&".$arVariableAliases["ELEMENT_ID"]."=#ELEMENT_ID#",
			"exampage" => htmlspecialcharsbx($APPLICATION->GetCurPage()).
			              "exam/new/?"
			              .$arVariableAliases["PARAM1"]."=#PARAM1#"
			              .'&'
			              .$arVariableAliases["PARAM2"]."=#PARAM2#",
		),


3 - формируем ссылку вручную
$url = $arResult['URL_TEMPLATES']['exampage'];
$arRepl=['#PARAM1#'=>123,
         '#PARAM2#'=>456];
$url=str_replace(array_keys($arRepl),$arRepl,$url);
в боевом режиме код параметра (PARAM*) брать из arResult['ALIASES']

4 - выводим переменные
<pre><?var_dump($arResult["VARIABLES"])?></pre>

**********************************************************************************************


